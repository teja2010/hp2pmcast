// Code generated by protoc-gen-go. DO NOT EDIT.
// source: narada.proto

package main

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type NEvalInfo struct {
	Hops                 int32    `protobuf:"varint,1,opt,name=hops,proto3" json:"hops,omitempty"`
	Time                 int64    `protobuf:"varint,2,opt,name=time,proto3" json:"time,omitempty"`
	Hostname             string   `protobuf:"bytes,3,opt,name=hostname,proto3" json:"hostname,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NEvalInfo) Reset()         { *m = NEvalInfo{} }
func (m *NEvalInfo) String() string { return proto.CompactTextString(m) }
func (*NEvalInfo) ProtoMessage()    {}
func (*NEvalInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_92500cdcd24be61e, []int{0}
}

func (m *NEvalInfo) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_NEvalInfo.Unmarshal(m, b)
}
func (m *NEvalInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_NEvalInfo.Marshal(b, m, deterministic)
}
func (m *NEvalInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NEvalInfo.Merge(m, src)
}
func (m *NEvalInfo) XXX_Size() int {
	return xxx_messageInfo_NEvalInfo.Size(m)
}
func (m *NEvalInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_NEvalInfo.DiscardUnknown(m)
}

var xxx_messageInfo_NEvalInfo proto.InternalMessageInfo

func (m *NEvalInfo) GetHops() int32 {
	if m != nil {
		return m.Hops
	}
	return 0
}

func (m *NEvalInfo) GetTime() int64 {
	if m != nil {
		return m.Time
	}
	return 0
}

func (m *NEvalInfo) GetHostname() string {
	if m != nil {
		return m.Hostname
	}
	return ""
}

type NFwdPacket struct {
	SrcHostname          string       `protobuf:"bytes,1,opt,name=SrcHostname,json=srcHostname,proto3" json:"SrcHostname,omitempty"`
	EvalList             []*NEvalInfo `protobuf:"bytes,2,rep,name=evalList,proto3" json:"evalList,omitempty"`
	Payload              []byte       `protobuf:"bytes,3,opt,name=payload,proto3" json:"payload,omitempty"`
	SeqNum               int32        `protobuf:"varint,4,opt,name=SeqNum,json=seqNum,proto3" json:"SeqNum,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *NFwdPacket) Reset()         { *m = NFwdPacket{} }
func (m *NFwdPacket) String() string { return proto.CompactTextString(m) }
func (*NFwdPacket) ProtoMessage()    {}
func (*NFwdPacket) Descriptor() ([]byte, []int) {
	return fileDescriptor_92500cdcd24be61e, []int{1}
}

func (m *NFwdPacket) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_NFwdPacket.Unmarshal(m, b)
}
func (m *NFwdPacket) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_NFwdPacket.Marshal(b, m, deterministic)
}
func (m *NFwdPacket) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NFwdPacket.Merge(m, src)
}
func (m *NFwdPacket) XXX_Size() int {
	return xxx_messageInfo_NFwdPacket.Size(m)
}
func (m *NFwdPacket) XXX_DiscardUnknown() {
	xxx_messageInfo_NFwdPacket.DiscardUnknown(m)
}

var xxx_messageInfo_NFwdPacket proto.InternalMessageInfo

func (m *NFwdPacket) GetSrcHostname() string {
	if m != nil {
		return m.SrcHostname
	}
	return ""
}

func (m *NFwdPacket) GetEvalList() []*NEvalInfo {
	if m != nil {
		return m.EvalList
	}
	return nil
}

func (m *NFwdPacket) GetPayload() []byte {
	if m != nil {
		return m.Payload
	}
	return nil
}

func (m *NFwdPacket) GetSeqNum() int32 {
	if m != nil {
		return m.SeqNum
	}
	return 0
}

type NEmpty struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NEmpty) Reset()         { *m = NEmpty{} }
func (m *NEmpty) String() string { return proto.CompactTextString(m) }
func (*NEmpty) ProtoMessage()    {}
func (*NEmpty) Descriptor() ([]byte, []int) {
	return fileDescriptor_92500cdcd24be61e, []int{2}
}

func (m *NEmpty) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_NEmpty.Unmarshal(m, b)
}
func (m *NEmpty) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_NEmpty.Marshal(b, m, deterministic)
}
func (m *NEmpty) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NEmpty.Merge(m, src)
}
func (m *NEmpty) XXX_Size() int {
	return xxx_messageInfo_NEmpty.Size(m)
}
func (m *NEmpty) XXX_DiscardUnknown() {
	xxx_messageInfo_NEmpty.DiscardUnknown(m)
}

var xxx_messageInfo_NEmpty proto.InternalMessageInfo

func init() {
	proto.RegisterType((*NEvalInfo)(nil), "main.NEvalInfo")
	proto.RegisterType((*NFwdPacket)(nil), "main.NFwdPacket")
	proto.RegisterType((*NEmpty)(nil), "main.NEmpty")
}

func init() { proto.RegisterFile("narada.proto", fileDescriptor_92500cdcd24be61e) }

var fileDescriptor_92500cdcd24be61e = []byte{
	// 248 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x44, 0x90, 0x41, 0x4f, 0xb3, 0x40,
	0x10, 0x86, 0xbf, 0x2d, 0x7c, 0x08, 0x03, 0x89, 0x66, 0x0e, 0x66, 0xd3, 0x13, 0xe1, 0x44, 0x62,
	0xe4, 0x50, 0xaf, 0x5e, 0xdb, 0x68, 0x62, 0x56, 0xb3, 0xfd, 0x05, 0x23, 0xac, 0x29, 0x91, 0x65,
	0x91, 0x5d, 0xdb, 0xf4, 0x47, 0xf8, 0x9f, 0x0d, 0xab, 0xe0, 0x6d, 0x9e, 0xc9, 0x3b, 0x99, 0x27,
	0x2f, 0x64, 0x3d, 0x8d, 0xd4, 0x50, 0x35, 0x8c, 0xc6, 0x19, 0x0c, 0x35, 0xb5, 0x7d, 0xf1, 0x0c,
	0x89, 0xd8, 0x1e, 0xa9, 0x7b, 0xec, 0xdf, 0x0c, 0x22, 0x84, 0x07, 0x33, 0x58, 0xce, 0x72, 0x56,
	0xfe, 0x97, 0x7e, 0x9e, 0x76, 0xae, 0xd5, 0x8a, 0xaf, 0x72, 0x56, 0x06, 0xd2, 0xcf, 0xb8, 0x86,
	0xf8, 0x60, 0xac, 0xeb, 0x49, 0x2b, 0x1e, 0xe4, 0xac, 0x4c, 0xe4, 0xc2, 0xc5, 0x17, 0x03, 0x10,
	0xbb, 0x53, 0xf3, 0x42, 0xf5, 0xbb, 0x72, 0x98, 0x43, 0xba, 0x1f, 0xeb, 0x87, 0x39, 0xcd, 0x7c,
	0x3a, 0xb5, 0x7f, 0x2b, 0xbc, 0x81, 0x58, 0x1d, 0xa9, 0x7b, 0x6a, 0xad, 0xe3, 0xab, 0x3c, 0x28,
	0xd3, 0xcd, 0x65, 0x35, 0xa9, 0x55, 0x8b, 0x97, 0x5c, 0x02, 0xc8, 0xe1, 0x62, 0xa0, 0x73, 0x67,
	0xa8, 0xf1, 0x8f, 0x33, 0x39, 0x23, 0x5e, 0x43, 0xb4, 0x57, 0x1f, 0xe2, 0x53, 0xf3, 0xd0, 0xdb,
	0x47, 0xd6, 0x53, 0x11, 0x43, 0x24, 0xb6, 0x7a, 0x70, 0xe7, 0xcd, 0x3d, 0xa4, 0x3f, 0x05, 0xe8,
	0x9a, 0xac, 0xc3, 0x5b, 0x48, 0x84, 0xc7, 0xdd, 0xa9, 0xc1, 0xab, 0xdf, 0x97, 0x8b, 0xf8, 0x3a,
	0x9b, 0x25, 0xa6, 0xdb, 0xe2, 0xdf, 0x6b, 0xe4, 0x5b, 0xbb, 0xfb, 0x0e, 0x00, 0x00, 0xff, 0xff,
	0xaa, 0xf3, 0xf1, 0x96, 0x45, 0x01, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConnInterface

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion6

// NaradamcastClient is the client API for Naradamcast service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type NaradamcastClient interface {
	NaradaFwd(ctx context.Context, in *NFwdPacket, opts ...grpc.CallOption) (*NEmpty, error)
}

type naradamcastClient struct {
	cc grpc.ClientConnInterface
}

func NewNaradamcastClient(cc grpc.ClientConnInterface) NaradamcastClient {
	return &naradamcastClient{cc}
}

func (c *naradamcastClient) NaradaFwd(ctx context.Context, in *NFwdPacket, opts ...grpc.CallOption) (*NEmpty, error) {
	out := new(NEmpty)
	err := c.cc.Invoke(ctx, "/main.naradamcast/NaradaFwd", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// NaradamcastServer is the server API for Naradamcast service.
type NaradamcastServer interface {
	NaradaFwd(context.Context, *NFwdPacket) (*NEmpty, error)
}

// UnimplementedNaradamcastServer can be embedded to have forward compatible implementations.
type UnimplementedNaradamcastServer struct {
}

func (*UnimplementedNaradamcastServer) NaradaFwd(ctx context.Context, req *NFwdPacket) (*NEmpty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NaradaFwd not implemented")
}

func RegisterNaradamcastServer(s *grpc.Server, srv NaradamcastServer) {
	s.RegisterService(&_Naradamcast_serviceDesc, srv)
}

func _Naradamcast_NaradaFwd_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NFwdPacket)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NaradamcastServer).NaradaFwd(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/main.naradamcast/NaradaFwd",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NaradamcastServer).NaradaFwd(ctx, req.(*NFwdPacket))
	}
	return interceptor(ctx, in, info, handler)
}

var _Naradamcast_serviceDesc = grpc.ServiceDesc{
	ServiceName: "main.naradamcast",
	HandlerType: (*NaradamcastServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "NaradaFwd",
			Handler:    _Naradamcast_NaradaFwd_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "narada.proto",
}
